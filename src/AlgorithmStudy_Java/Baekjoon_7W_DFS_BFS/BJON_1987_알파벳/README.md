# [Gold IV] 알파벳 - 1987

[문제 링크](https://www.acmicpc.net/problem/1987)

### 성능 요약

메모리: 24772 KB, 시간: 1228 ms

### 분류

백트래킹(backtracking), 깊이 우선 탐색(dfs), 그래프 이론(graphs), 그래프 탐색(graph_traversal)

### 문제 설명

<p>세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.</p>

<p>말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.</p>

<p>좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.</p>

### 입력

 <p>첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.</p>

### 출력

 <p>첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.</p>



<br>

---

<br>

새벽에 졸린 눈으로 이래저래 시도하다 운 좋게 풀어버린 문제..

1. 입력값 `A~Z` 를 `A`를 빼며 배열에 0~25로 저장하여 `visited` 배열을 만듬
2. `map[0][0]`에서부터 dfs탐색을 하며 마지막까지 확인하고 재귀함수가 돌아올때 visited의  true를 cnt에 카운트하고(방문 횟수) max값을 비교하여 저장한다.
3. 그리고 visited를 false로 초기화하며 재귀를 빠져나온다.
4. 가장 먼저 시작한 재귀함수에서 초기화된 visited를 가지고 2와 3을 반복한다.
=> [0][0] 에서 시작하여 [r][n]까지 검사하는 것는 확정이고 처음 `하`, `우` 만 검사하면 된다.

